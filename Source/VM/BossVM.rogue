module Boss

local vm = BossVM()

local m_add = vm.type_Object.add_method( "add",
  function(task:BossTask)
    local lhs_type = task.arg_type( 1 )
    local rhs_type = task.arg_type( 1 )
    if (lhs_type.is_string or rhs_type.is_string)
      task.push( task.arg_string(1) + task.arg_string(2) )
    elseIf (lhs_type.is_undefined or rhs_type.is_undefined)
      task.push_undefined
    elseIf (lhs_type.is_number or rhs_type.is_number)
      task.push( task.arg_real64(1) + task.arg_real64(2) )
    else
      task.push( NaN )
    endIf
  endFunction
)

vm.type_Object.add_method( "wow", (task) => println "Woo-hoo!" )

local m_hello = vm.type_Object.add_method( "hello" )
m_hello.write( BossOpcode.READ_THIS )
m_hello.write( BossOpcode.READ_THIS )
m_hello.write( BossOpcode.STRING,  "Hello World!" )
m_hello.write( BossOpcode.STRING,  "!!" )
m_hello.write_call( "add", 2 )
m_hello.write( BossOpcode.READ_THIS )
m_hello.write( BossOpcode.LITERAL_INT32, 5 )
m_hello.write( BossOpcode.LITERAL_INT32, 6 )
m_hello.write_call( "add", 2 )
m_hello.write_call( "add", 2 )
m_hello.write( BossOpcode.PRINT )
m_hello.write( BossOpcode.PRINTLN )
m_hello.write( BossOpcode.READ_THIS )
m_hello.write_call( "wow" )
#m_hello.write( BossOpcode.READ_THIS )
#m_hello.write( BossOpcode.PRINT )
#m_hello.write( BossOpcode.PRINTLN )
m_hello.write( BossOpcode.REPEAT, 1 )
m_hello.write( 0 )
m_hello.write( BossOpcode.RETURN )

BossObject( "Object" ).call( "hello" )

class BossVM [singleton]
  PROPERTIES
    objects          = BossObject[]
    strings          = BossStringIndexTable()
    identifiers      = BossStringIndexTable()
    real64s          = Real64[]

    types            = StringTable<<BossType>>()
    type_list        = BossType[]

    type_undefined   : BossType
    type_null        : BossType
    type_Logical     : BossType
    type_Int32       : BossType
    type_Real64      : BossType
    type_String      : BossType
    type_Object      : BossType

    no_such_method   : BossTask

  METHODS
    method init
      BossVM = this

      type_undefined    = BossTypeUndefined()
      type_null         = BossTypeNull()
      type_Logical      = BossTypeLogical()
      type_Int32        = BossTypeInt32()
      type_Real64       = BossTypeReal64()
      type_String       = BossTypeString()
      type_Object       = BossTypeObject()

      ensure no_such_method

    method add_object( object:BossObject )->Int32
      local index = objects.count
      objects.add( object )
      return index

    method op_add( stack:Real64[], lhs_sp:Int32, lhs_type:BossType, rhs_sp:Int32, rhs_type:BossType )
      if (lhs_type is type_String or rhs_type is type_String)
        local result = lhs_type->String(stack,lhs_sp) + rhs_type->String(stack,rhs_sp)
        stack.add( type_String.type_index ).add( BossVM.strings.add(result) )

      elseIf (lhs_type is type_undefined or rhs_type is type_undefined)
        stack.add( type_Real64.type_index ).add( NaN )

      elseIf (lhs_type.is_numberlike or rhs_type.is_numberlike)
        local result = lhs_type->Real64(stack,lhs_sp) + rhs_type->Real64(stack,rhs_sp)
        stack.add( type_Real64.type_index ).add( result )

      else
        stack.add( type_Real64.type_index ).add( NaN )

      endIf
endClass


class BossType
  PROPERTIES
    slot_count    : Int32
    type_index    : Int32
    name_index    : Int32
    is_numberlike : Logical
    methods       = BossMethod[](5)
    method_lookup = Table<<Int32,Int32>>()

  METHODS
    method init( name:String, slot_count=2, is_numberlike=false )
      name_index = BossVM.identifiers.index( name )

      local entry = BossVM.types.find( name )
      if (entry)
        # Replace existing type definition
        type_index = entry.value.type_index
        BossVM.type_list[ type_index ] = this
      else
        type_index = BossVM.type_list.count
        BossVM.type_list.add( this )
      endIf
      BossVM.types[ name ] = this

    method add_method( m:BossMethod )->BossMethod
      local entry = method_lookup.find( m.name_index )
      if (entry)
        methods[ entry.value ] = m
      else
        local slot = methods.count
        methods.add( m )
        method_lookup[ m.name_index ] = slot
      endIf
      return m

    method add_method( m_name:String, native_handler=null:Function(BossTask) )->BossMethod
      return add_method( BossMethod(m_name,native_handler) )

    method is_int32->Logical
      return false

    method is_logical->Logical
      return false

    method is_null->Logical
      return false

    method is_number->Logical
      return false

    method is_object->Logical
      return false

    method is_real64->Logical
      return false

    method is_string->Logical
      return false

    method is_undefined->Logical
      return false

    method locate_method( m_name:String )->Int32?
      return locate_method( BossVM.identifiers.index(m_name) )

    method locate_method( m_name_index:Int32 )->Int32?
      local entry = method_lookup.find( m_name_index )
      if (entry) return entry.value
      else       return null

    method name->String
      return BossVM.identifiers[ name_index ]

    method op_add( stack:Real64[], lhs_sp:Int32, rhs_sp:Int32, rhs_type:BossType )
      stack.add( BossVM.type_undefined.type_index )

    method to->Int32( stack:Real64[], sp:Int32 )
      return 0

    method to->Logical( stack:Real64[], sp:Int32 )
      return false

    method to->Real64( stack:Real64[], sp:Int32 )
      return 0.0

    method to->String
      return name

    method to->String( stack:Real64[], sp:Int32 )
      return name + "@" + sp
endClass


class BossTypeInt32 : BossType
  METHODS
    method init
      prior.init( "Int32", &is_numberlike )

    method is_int32->Logical
      return true

    method is_number->Logical
      return true

    method to->Int32( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]->Int32

    method to->Logical( stack:Real64[], sp:Int32 )
      return (stack[sp+1] != 0)

    method to->Real64( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]

    method to->String( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]->Int32->String
endClass


class BossTypeLogical : BossType
  METHODS
    method init
      prior.init( "Logical", &is_numberlike )

    method is_logical->Logical
      return true

    method to->Int32( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]->Int32

    method to->Logical( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ] != 0

    method to->Real64( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]

    method to->String( stack:Real64[], sp:Int32 )
      return ?:{ stack[sp+1]:"true" || "false" }

endClass


class BossTypeNull : BossType
  METHODS
    method init
      prior.init( "null", &slot_count=1, &is_numberlike )

    method is_null->Logical
      return true

    method to->String( stack:Real64[], sp:Int32 )
      return "null"
endClass


class BossTypeObject : BossType
  METHODS
    method init
      prior.init( "Object" )

    method is_object->Logical
      return true

    method to->Logical( stack:Real64[], sp:Int32 )
      return true

    method to->String( stack:Real64[], sp:Int32 )
      return BossVM.objects[ stack[ sp+1 ] ]->String
endClass


class BossTypeReal64 : BossType
  METHODS
    method init
      prior.init( "Real64", &is_numberlike )

    method is_number->Logical
      return true

    method is_real64->Logical
      return true

    method to->Int32( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]->Int32

    method to->Logical( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ] != 0

    method to->Real64( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]

    method to->String( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]->String
endClass


class BossTypeString : BossType
  METHODS
    method init
      prior.init( "String" )

    method is_string->Logical
      return true

    method to->Int32( stack:Real64[], sp:Int32 )
      return BossVM.strings[ stack[ sp+1 ] ]->Int32

    method to->Logical( stack:Real64[], sp:Int32 )
      return true

    method to->Real64( stack:Real64[], sp:Int32 )
      return BossVM.strings[ stack[ sp+1 ] ]->Real64

    method to->String( stack:Real64[], sp:Int32 )
      return BossVM.strings[ stack[ sp+1 ] ]
endClass


class BossTypeUndefined : BossType
  METHODS
    method init
      prior.init( "undefined", &slot_count=1 )

    method is_undefined->Logical
      return true

    method to->String( stack:Real64[], sp:Int32 )
      return "undefined"
endClass


class BossObject
  PROPERTIES
    type         : BossType
    object_index : Int32

  METHODS
    method init( type_name:String )
      type = ?:{ BossVM.types[type_name] || BossVM.type_Object }
      object_index = BossVM.add_object( this )

    method call( method_name:String )->BossTask
      local slot = type.locate_method( method_name )
      if (slot.exists)
        local task = BossTask( type.methods[slot.value] )
        task.push( this )
        task.execute
        return task
      else
        return BossVM.no_such_method
      endIf
endClass


enum BossOpcode
  NOP
  HALT
  RETURN
  CALL
  REPEAT
  LITERAL_INT32
  LITERAL_REAL64
  STRING
  READ_THIS
  READ_ARG_1
  READ_ARG_2
  READ_ARG_3
  READ_ARG_N
  ADD
  PRINT
  PRINTLN
endEnum


class BossMethod
  PROPERTIES
    name_index     : Int32
    code           : Int32[]
    native_handler : Function(BossTask)

  METHODS
    method init( name:String, native_handler=null )
      name_index = BossVM.identifiers.index( name )
      ensure code

    method ip->Int32
      return code.count

    method name->String
      return BossVM.identifiers[ name_index ]

    method to->String
      return name + "()"

    method write( opcode:BossOpcode, value:Int32 )
      write( opcode->Int32 )
      write( value )

    method write( opcode:BossOpcode, value:Real64 )
      write( opcode->Int32 )
      write( BossVM.real64s.count )
      BossVM.real64s.add( value )

    method write( opcode:BossOpcode, value:String )
      write( opcode->Int32 )
      write( value )

    method write( opcode:BossOpcode )
      code.add( opcode->Int32 )

    method write( value:Int32 )
      code.add( value )

    method write( value:String )
      write( BossVM.strings.index(value) )

    method write_call( method_name:String, arg_count=0:Int32 )
      write( BossOpcode.CALL )
      write( BossVM.identifiers.index(method_name) )
      write( 0 )
      write( 0 )
      write( arg_count )

endClass


class BossCallFrame( m:BossMethod, fp=0:Int32, arg_count=0:Int32, ip=0:Int32 ) [compound]
  METHODS
    method to->String
      return "$ @$" (m,ip)
endClass


class BossTask
  PROPERTIES
    vm          : BossVM
    stack       : Real64[]
    stack_index : Int32[]
    frame       : BossCallFrame
    call_stack  : BossCallFrame[]

    exists      = true
    is_finished : Logical

    repeat_call : Logical

  METHODS
    method init
      exists = false
      is_finished = true
      (ensure stack_index(1)).add( 0 )
      (ensure stack(1)).add( BossVM.type_undefined.type_index )

    method init( m:BossMethod )
      ensure stack
      ensure stack_index
      ensure call_stack

      vm = BossVM
      frame = BossCallFrame( m )

    method arg_count->Int32
      return frame.arg_count

    method arg_int32( index:Int32 )->Int32
      local type = arg_type( index )
      if (type.is_undefined) return 0
      return type->Int32( stack, stack_index[frame.fp+index] )

    method arg_logical( index:Int32 )->Logical
      local type = arg_type( index )
      if (type.is_undefined) return 0
      return type->Logical( stack, stack_index[frame.fp+index] )

    method arg_real64( index:Int32 )->Real64
      local type = arg_type( index )
      if (type.is_undefined) return 0.0
      return type->Int32( stack, stack_index[frame.fp+index] )

    method arg_string( index:Int32 )->String
      local type = arg_type( index )
      if (type.is_undefined) return 0
      return type->String( stack, stack_index[frame.fp+index] )

    method arg_type( index:Int32 )->BossType
      if (index < 0 or index > frame.arg_count) return vm.type_undefined
      return vm.type_list[ stack[stack_index[frame.fp + index]] ]

    method execute->Logical
      if (is_finished) return false

      local vm          = this.vm
      local stack       = this.stack
      local stack_index = this.stack_index
      local frame       = this.frame
      local code        = frame.m.code
      local type_list   = BossVM.type_list
      loop
        local opcode = BossOpcode( code[ frame.ip ] )
        ++frame.ip
        which (opcode)
          case BossOpcode.NOP
            noAction

          case BossOpcode.HALT
            this.frame = frame
            is_finished = true
            return false

          case BossOpcode.RETURN
            local result_sp = stack_index.last
            local is_return_value_specified = stack_index.count > (frame.fp+frame.arg_count+1)

            # Unwind stack
            local should_halt = false
            if (call_stack.count)
              local old_fp = frame.fp
              frame = call_stack.remove_last
              stack.count = stack_index[ old_fp ]
              stack_index.count = old_fp + 1    # stack_index.last has correct value
              code = frame.m.code
            else
              # set count instead of clear() to avoid zeroing data; stack_index.last has correct value
              stack_index.count = 1
              stack.count = 0
              should_halt = true
            endIf

            if (is_return_value_specified)
              # The stack has at least one extra value on it; copy it over as the result
              loop type_list[ stack[result_sp] ].slot_count
                stack.add( stack[result_sp] )
                ++result_sp
              endLoop
            else
              # No return value pushed on stack; add an 'undefined'.
              stack.add( vm.type_undefined.type_index )
            endIf

            if (should_halt)
              this.frame = frame
              is_finished = true
              return false
            endIf

          case BossOpcode.CALL
            # code[ip-5] : CALL
            # code[ip-4] : method name_index
            # code[ip-3] : cached type index
            # code[ip-2] : cached method slot
            # code[ip-1] : N (arg count)
            block
              frame.ip += 4
              local arg_count     = code[ frame.ip - 1 ]
              local context_index = stack_index.count - (arg_count+1)
              local context_sp    = stack_index[ context_index ]
              local context_type  = type_list[ stack[context_sp] ]
              local m : BossMethod
              if (context_type.type_index == code[frame.ip-3])
                m = context_type.methods[ code[frame.ip-2] ]
              else
                local slot = context_type.locate_method( code[frame.ip-4] )
                if (slot.exists)
                  # Cache type index and slot index
                  code[ frame.ip-3 ] = context_type.type_index
                  code[ frame.ip-2 ] = slot.value
                  m = context_type.methods[ slot.value ]
                else
                  # Method not found; pop context + args and replace with "undefined"
                  stack_index.count = context_index + 1
                  stack.count = context_sp + 1
                  stack[ context_sp ] = vm.type_undefined.type_index
                  escapeBlock
                endIf
              endIf
              call_stack.add( frame )
              frame = BossCallFrame( m, context_index, arg_count )
              if (m.native_handler)
                this.frame = frame
                m.native_handler( this )   # may set 'repeat_call'
                if (repeat_call)
                  repeat_call = false
                  frame = call_stack.remove_last
                  frame.ip -= 5
                else
                  # perform RETURN
                  local result_sp = stack_index.last
                  local is_return_value_specified = stack_index.count > (frame.fp+frame.arg_count+1)

                  # Unwind stack
                  local old_fp = frame.fp
                  frame = call_stack.remove_last
                  stack.count = stack_index[ old_fp ]
                  stack_index.count = old_fp + 1    # stack_index.last has correct value
                  code = frame.m.code

                  if (is_return_value_specified)
                    # The stack has at least one extra value on it; copy it over as the result
                    loop type_list[ stack[result_sp] ].slot_count
                      stack.add( stack[result_sp] )
                      ++result_sp
                    endLoop
                  else
                    # No return value pushed on stack; add an 'undefined'.
                    stack.add( vm.type_undefined.type_index )
                  endIf
                endIf
              else
                code = m.code
              endIf
            endBlock

          case BossOpcode.REPEAT
            if (code[frame.ip])
              --code[ frame.ip ]
              frame.ip = code[ frame.ip + 1 ]
            else
              frame.ip += 2
            endIf

          case BossOpcode.LITERAL_INT32
            stack_index.add( stack.count )
            stack.add( vm.type_Int32.type_index )
            stack.add( code[frame.ip] )
            ++frame.ip

          case BossOpcode.LITERAL_REAL64
            stack_index.add( stack.count )
            stack.add( vm.type_Real64.type_index )
            stack.add( vm.real64s[code[frame.ip]] )
            ++frame.ip

          case BossOpcode.STRING
            stack_index.add( stack.count )
            stack.add( vm.type_String.type_index )
            stack.add( code[frame.ip] )
            ++frame.ip

          case BossOpcode.READ_THIS
            stack_index.add( stack.count )
            local src = stack_index[ frame.fp ]
            local type_index = stack[ src ]
            loop type_list[ type_index ].slot_count
              stack.add( stack[src] )
              ++src
            endLoop

          case BossOpcode.READ_ARG_1
            stack_index.add( stack.count )
            local src = stack_index[ frame.fp + 1 ]
            local type_index = stack[ src ]
            loop type_list[ type_index ].slot_count
              stack.add( stack[src] )
              ++src
            endLoop

          case BossOpcode.READ_ARG_2
            stack_index.add( stack.count )
            local src = stack_index[ frame.fp + 2 ]
            local type_index = stack[ src ]
            loop type_list[ type_index ].slot_count
              stack.add( stack[src] )
              ++src
            endLoop

          case BossOpcode.READ_ARG_3
            stack_index.add( stack.count )
            local src = stack_index[ frame.fp + 3 ]
            local type_index = stack[ src ]
            loop type_list[ type_index ].slot_count
              stack.add( stack[src] )
              ++src
            endLoop

          case BossOpcode.READ_ARG_N
            stack_index.add( stack.count )
            local src = stack_index[ frame.fp + code[frame.ip] ]
            ++frame.ip
            local type_index = stack[ src ]
            loop type_list[ type_index ].slot_count
              stack.add( stack[src] )
              ++src
            endLoop

          case BossOpcode.ADD
            local rhs_sp = stack_index.remove_last
            local lhs_sp = stack_index.last
            stack.count = lhs_sp
            vm.op_add( stack, lhs_sp, type_list[stack[lhs_sp]->Int32], rhs_sp, type_list[stack[rhs_sp]->Int32] )

          case BossOpcode.PRINT
            local sp = stack_index.remove_last
            print vm.type_list[ stack[sp]->Int32 ]->String( stack, sp )
            stack.count = sp

          case BossOpcode.PRINTLN
            println

          others
            throw Error( "Unhandled opcode in BossVM: " + opcode )
        endWhich
      endLoop

    method push( value:Int32 )->this
      stack_index.add( stack.count )
      stack.add( vm.type_Int32.type_index )
      stack.add( value )
      return this

    method push( value:Logical )->this
      stack_index.add( stack.count )
      stack.add( vm.type_Logical.type_index )
      stack.add( ?:{value:1||0} )
      return this

    method push( object:BossObject )->this
      if (object is null) return push_null
      stack_index.add( stack.count )
      stack.add( object.type.type_index  )
      stack.add( object.object_index  )
      return this

    method push( value:Real64 )->this
      stack_index.add( stack.count )
      stack.add( vm.type_Real64.type_index )
      stack.add( value )
      return this

    method push( value:String )->this
      stack_index.add( stack.count )
      stack.add( vm.type_String.type_index )
      stack.add( vm.strings.add(value) )
      return this

    method push_null->this
      stack_index.add( stack.count )
      stack.add( vm.type_null.type_index )
      return this

    method push_undefined->this
      stack_index.add( stack.count )
      stack.add( vm.type_undefined.type_index )
      return this

endClass


class BossStringIndexTable
  PROPERTIES
    list  : String[]
    table = StringTable<<Int32>>()

  METHODS
    method init
      init( 10 )

    method init( initial_capacity:Int32 )
      ensure list( initial_capacity )

    method add( value:String )->Int32
      # Adds a string without comparing it to existing strings
      list.add( value )
      return list.count - 1

    method count->Int32 [macro]
      this.list.count

    method get( index:Int32 )->String
      return list[ index ]

    method index( value:String )->Int32
      local entry = table.find( value )
      if (entry) return entry.value

      local index = list.count
      list.add( value )
      table[ value ] = index
      return index

endClass

