module Boss

local vm = BossVM()

local m_add = vm.type_Object.add_method( "add" )
m_add.write( BossOpcode.READ_ARG_1 )
m_add.write( BossOpcode.READ_ARG_2 )
m_add.write( BossOpcode.ADD )
m_add.write( BossOpcode.RETURN )

local m_hello = vm.type_Object.add_method( "hello" )
m_hello.write( BossOpcode.STRING,  "Hello World!" )
m_hello.write( BossOpcode.STRING,  "!!" )
#m_hello.write( BossOpcode.LITERAL_INT32, 5 )
#m_hello.write( BossOpcode.LITERAL_INT32, 6 )
m_hello.write( BossOpcode.ADD )
m_hello.write( BossOpcode.PRINT )
m_hello.write( BossOpcode.PRINTLN )
m_hello.write( BossOpcode.HALT )

BossObject( "Object" ).call( "hello" )

class BossVM [singleton]
  PROPERTIES
    objects          = BossObject[]
    strings          = BossStringIndexTable()
    identifiers      = BossStringIndexTable()
    real64s          = Real64[]

    types            = StringTable<<BossType>>()
    type_list        = BossType[]

    type_undefined   : BossType
    type_null        : BossType
    type_LogicalTrue : BossType
    type_LogicalFalse: BossType
    type_Int32       : BossType
    type_Real64      : BossType
    type_String      : BossType
    type_Object      : BossType

    no_such_method   : BossTask

  METHODS
    method init
      BossVM = this

      type_undefined    = BossType( "undefined",    BossValueType.UNDEFINED )
      type_null         = BossType( "null",         BossValueType.NULL )
      type_LogicalTrue  = BossType( "LogicalTrue",  BossValueType.LOGICAL_TRUE )
      type_LogicalFalse = BossType( "LogicalFalse", BossValueType.LOGICAL_FALSE )
      type_Int32        = BossTypeInt32()
      type_Real64       = BossType( "Real64",       BossValueType.REAL64 )
      type_String       = BossTypeString()
      type_Object       = BossType( "Object",       BossValueType.OBJECT )

      ensure no_such_method

    method add_object( object:BossObject )->Int32
      local index = objects.count
      objects.add( object )
      return index

endClass


enum BossValueType
  UNDEFINED
  NULL
  LOGICAL_FALSE
  LOGICAL_TRUE
  INT32
  REAL64
  STRING
  OBJECT
endEnum


class BossType
  PROPERTIES
    value_type    : BossValueType
    slot_count    = 1
    type_index    : Int32
    name_index    : Int32
    methods       = BossMethod[](5)
    method_lookup = Table<<Int32,Int32>>()

  METHODS
    method init( name:String, value_type=BossValueType.OBJECT )
      name_index = BossVM.identifiers.index( name )

      local entry = BossVM.types.find( name )
      if (entry)
        # Replace existing type definition
        type_index = entry.value.type_index
        BossVM.type_list[ type_index ] = this
      else
        type_index = BossVM.type_list.count
        BossVM.type_list.add( this )
      endIf
      BossVM.types[ name ] = this

    method add_method( m:BossMethod )->BossMethod
      local entry = method_lookup.find( m.name_index )
      if (entry)
        methods[ entry.value ] = m
      else
        local slot = methods.count
        methods.add( m )
        method_lookup[ m.name_index ] = slot
      endIf
      return m

    method add_method( m_name:String )->BossMethod
      return add_method( BossMethod(m_name) )

    method locate_method( m_name:String )->Int32?
      local entry = method_lookup.find( BossVM.identifiers.index(m_name) )
      if (entry) return entry.value
      else       return null

    method name->String
      return BossVM.identifiers[ name_index ]

    method op_add( stack:Real64[], lhs_sp:Int32, rhs_sp:Int32, rhs_type:BossType )
      stack.add( BossVM.type_undefined.type_index )

    method to->String
      return name

    method to->String( stack:Real64[], sp:Int32 )
      return name + "@" + sp
endClass


class BossTypeInt32 : BossType
  METHODS
    method init
      prior.init( "Int32", BossValueType.INT32 )

    method op_add( stack:Real64[], lhs_sp:Int32, rhs_sp:Int32, rhs_type:BossType )
      which (rhs_type.value_type)
        case BossValueType.UNDEFINED, BossValueType.NULL
          stack.add( rhs_type.type_index )
        case BossValueType.LOGICAL_FALSE
          stack.add( type_index ).add( stack[lhs_sp+1] )
        case BossValueType.LOGICAL_TRUE
          stack.add( type_index ).add( stack[lhs_sp+1] + 1 )
        case BossValueType.INT32
          stack.add( type_index ).add( stack[lhs_sp+1] + stack[rhs_sp+1] )
        case BossValueType.REAL64
          stack.add( rhs_type.type_index ).add( stack[lhs_sp+1] + stack[rhs_sp+1] )
        case BossValueType.STRING
          stack.add( rhs_type.type_index ).add( stack[lhs_sp+1]->Int32 + BossVM.strings[stack[rhs_sp+1]] )
        case BossValueType.OBJECT
          stack.add( BossVM.type_undefined.type_index )
        others
          stack.add( BossVM.type_undefined.type_index )
      endWhich

    method to->String( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]->Int32->String
endClass

class BossTypeString : BossType
  METHODS
    method init
      prior.init( "String", BossValueType.STRING )

    method op_add( stack:Real64[], lhs_sp:Int32, rhs_sp:Int32, rhs_type:BossType )
      local result = BossVM.strings[stack[lhs_sp+1]] + rhs_type->String(stack,rhs_sp)
      stack.add( type_index )
      stack.add( BossVM.strings.count )
      BossVM.strings.list.add( result )

    method to->String( stack:Real64[], sp:Int32 )
      return BossVM.strings[ stack[ sp+1 ] ]
endClass


class BossObject
  PROPERTIES
    type         : BossType
    object_index : Int32

  METHODS
    method init( type_name:String )
      type = ?:{ BossVM.types[type_name] || BossVM.type_Object }
      object_index = BossVM.add_object( this )

    method call( method_name:String )->BossTask
      local slot = type.locate_method( method_name )
      if (slot.exists)
        local task = BossTask( type.methods[slot.value] )
        task.push_datatype( type.type_index )
        task.push( object_index )
        task.execute
        return task
      else
        return BossVM.no_such_method
      endIf
endClass


enum BossOpcode
  NOP
  HALT
  RETURN
  CALL_0
  CALL_1
  CALL_2
  CALL_N
  LITERAL_INT32
  LITERAL_REAL64
  STRING
  READ_THIS
  READ_ARG_1
  READ_ARG_2
  READ_ARG_3
  READ_ARG_N
  ADD
  PRINT
  PRINTLN
endEnum


class BossMethod
  PROPERTIES
    name_index : Int32
    code       : Int32[]

  METHODS
    method init( name:String )
      name_index = BossVM.identifiers.index( name )
      ensure code

    method name->String
      return BossVM.identifiers[ name_index ]

    method to->String
      return name + "()"

    method write( opcode:BossOpcode, value:Int32 )->Int32
      write( opcode->Int32 )
      return write( value )

    method write( opcode:BossOpcode, value:Real64 )->Int32
      write( opcode->Int32 )
      BossVM.real64s.add( value )
      return write( BossVM.real64s.count - 1 )

    method write( opcode:BossOpcode, value:String )->Int32
      write( opcode->Int32 )
      return write( value )

    method write( opcode:BossOpcode )->Int32
      code.add( opcode->Int32 )
      return code.count - 1

    method write( value:Int32 )->Int32
      code.add( value )
      return code.count - 1

    method write( value:String )->Int32
      return write( BossVM.strings.index(value) )
endClass


class BossCallFrame( m:BossMethod, ip=0:Int32, fp=0:Int32, arg_count=0:Int32, sp=0:Int32 ) [compound]
  METHODS
    method to->String
      return "$ @$" (m,ip)
endClass


class BossTask
  PROPERTIES
    vm          : BossVM
    stack       : Real64[]
    stack_index : Int32[]
    frame       : BossCallFrame
    call_stack  : BossCallFrame[]

    exists      = true
    is_finished : Logical

  METHODS
    method init
      exists = false
      is_finished = true
      (ensure stack_index(1)).add( 0 )
      (ensure stack(1)).add( BossVM.type_undefined.type_index )

    method init( m:BossMethod )
      ensure stack
      ensure stack_index
      ensure call_stack

      vm = BossVM
      frame = BossCallFrame( m )

    method execute->Logical
      if (is_finished) return false

      local vm          = this.vm
      local stack       = this.stack
      local stack_index = this.stack_index
      local frame       = this.frame
      local code        = frame.m.code
      local type_list   = BossVM.type_list
      loop
        local opcode = BossOpcode( code[ frame.ip ] )
        ++frame.ip
        which (opcode)
          case BossOpcode.NOP
            noAction

          case BossOpcode.HALT
            this.frame = frame
            is_finished = true
            return false

            #{

          case BossOpcode.RETURN
            local result = ?:{ stack.count>frame.fp+frame.arg_count:stack.last || BossValue.UNDEFINED }
            if (call_stack.count)
              frame = call_stack.remove_last
              stack.discard_from( frame.fp + frame.arg_count + 1 )
              local slot_count = result.type.slot_count
              if (slot_count == 1)
                data_stack.discard_from( frame.dsp )
              else
                local dest = frame.dsp
                local src = result.value->Int32
                if (src != dest)
                  result.value = src
                  loop slot_count
                    data_stack[ dest ] = data_stack[ src ]
                    ++dest
                    ++src
                  endLoop
                else
                  dest += slot_count
                endIf
                data_stack.discard_from( dest )
              endIf
              stack.add( result )

            else
              stack.clear.add( result )
              this.frame = frame
              is_finished = true
              return false
            endIf

          case BossOpcode.CALL_0

          case BossOpcode.CALL_1

          case BossOpcode.CALL_2
            #call_stack.add( frame )
            #local context = stack[ stack.count - 2 ]
            #if (code[frame.ip+1] == context.type

          case BossOpcode.CALL_N
            }#

          case BossOpcode.LITERAL_INT32
            stack_index.add( stack.count )
            stack.add( BossVM.type_Int32.type_index )
            stack.add( code[frame.ip] )
            ++frame.ip

            #{
          case BossOpcode.LITERAL_REAL64
            stack.add( BossValue(vm.real64s[code[frame.ip]]) )
            ++frame.ip
            }#

          case BossOpcode.STRING
            stack_index.add( stack.count )
            stack.add( BossVM.type_String.type_index )
            stack.add( code[frame.ip] )
            ++frame.ip

            #{
          case BossOpcode.READ_THIS
            stack.add( stack[frame.fp] )

          case BossOpcode.READ_ARG_1
            stack.add( stack[frame.fp+1] )

          case BossOpcode.READ_ARG_2
            stack.add( stack[frame.fp+2] )

          case BossOpcode.READ_ARG_3
            stack.add( stack[frame.fp+3] )

          case BossOpcode.READ_ARG_N
            stack.add( stack[frame.fp+code[frame.ip]] )
            ++frame.ip
            }#

          case BossOpcode.ADD
            local rhs_sp = stack_index.remove_last
            local lhs_sp = stack_index.last
            stack.count = lhs_sp
            type_list[ stack[lhs_sp]->Int32 ].op_add( stack, lhs_sp, rhs_sp, type_list[stack[rhs_sp]->Int32] )

          case BossOpcode.PRINT
            local sp = stack_index.remove_last
            print BossVM.type_list[ stack[sp]->Int32 ]->String( stack, sp )
            stack.count = sp

          case BossOpcode.PRINTLN
            println

          others
            throw Error( "Unhandled opcode in BossVM: " + opcode )
        endWhich
      endLoop

    method push_datatype( type_index:Int32 )->this
      stack_index.add( stack.count )
      stack.add( type_index  )
      return this

    method push( value:Real64 )->this
      stack.add( value )
      return this

    method push( value:Logical )->this
      stack.add( ?:{value:1||0} )
      return this

    method push_arg_type( arg_type_index:Int32 )->this
      stack_index.add( stack.count )
      stack.add( arg_type_index )
      ++frame.arg_count
      return this

endClass


class BossStringIndexTable
  PROPERTIES
    list  : String[]
    table = StringTable<<Int32>>()

  METHODS
    method init
      init( 10 )

    method init( initial_capacity:Int32 )
      ensure list( initial_capacity )

    method count->Int32 [macro]
      this.list.count

    method get( index:Int32 )->String
      return list[ index ]

    method index( value:String )->Int32
      local entry = table.find( value )
      if (entry) return entry.value

      local index = list.count
      list.add( value )
      table[ value ] = index
      return index

endClass

