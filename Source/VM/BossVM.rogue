module Boss

local vm = BossVM()

local type_Custom = vm.define_type( "Custom" ).extends( "Object" )

local m_test = vm.find_type("Object").create_method( "test" )
m_test.write( BossOpcode.STRING, "Hello World!" )
m_test.write( BossOpcode.PRINT )
m_test.write( BossOpcode.PRINTLN )
m_test.write( BossOpcode.RETURN )

BossObject( "Custom" ).call( "test" )

m_test = vm.find_type("Object").create_method( "test" )
m_test.write( BossOpcode.STRING, "It changed!" )
m_test.write( BossOpcode.PRINT )
m_test.write( BossOpcode.PRINTLN )
m_test.write( BossOpcode.RETURN )

BossObject( "Custom" ).call( "test" )

class BossVM [singleton]
  PROPERTIES
    objects          = BossObject[]
    strings          = BossStringIndexTable()
    identifiers      = BossStringIndexTable()
    real64s          = Real64[]

    types            = BossType[]
    type_lookup      = StringTable<<BossType>>()

    methods          = BossMethod[]

    type_undefined   : BossType
    type_null        : BossType
    type_Logical     : BossType
    type_Int32       : BossType
    type_Real64      : BossType
    type_String      : BossType
    type_Object      : BossType

    no_such_method   : BossTask

    visited_types    = BossType[]

  METHODS
    method init
      BossVM = this

      type_undefined    = BossTypeUndefined( this )
      type_null         = BossTypeNull( this )
      type_Logical      = BossTypeLogical( this )
      type_Int32        = BossTypeInt32( this )
      type_Real64       = BossTypeReal64( this )
      type_String       = BossTypeString( this )
      type_Object       = BossTypeObject( this )

      ensure no_such_method

    method add_object( object:BossObject )->Int32
      local index = objects.count
      objects.add( object )
      return index

    method define_type( type_name:String, base_name=null:String )->BossType
      local type = find_type( type_name )
      if (not type) type = BossTypeObject( this, type_name )
      if (not type.base_types.count) type.base_types.add( type_Object )
      if (base_name) type.extends( base_name )
      return type

    method find_type( name:String )->BossType
      local entry = type_lookup.find( name )
      if (entry) return entry.value
      else       return null

    method op_add( stack:Real64[], lhs_sp:Int32, lhs_type:BossType, rhs_sp:Int32, rhs_type:BossType )
      if (lhs_type is type_String or rhs_type is type_String)
        local result = lhs_type->String(stack,lhs_sp) + rhs_type->String(stack,rhs_sp)
        stack.add( type_String.type_index ).add( BossVM.strings.add(result) )

      elseIf (lhs_type is type_undefined or rhs_type is type_undefined)
        stack.add( type_Real64.type_index ).add( NaN )

      elseIf (lhs_type.is_numberlike or rhs_type.is_numberlike)
        local result = lhs_type->Real64(stack,lhs_sp) + rhs_type->Real64(stack,rhs_sp)
        stack.add( type_Real64.type_index ).add( result )

      else
        stack.add( type_Real64.type_index ).add( NaN )

      endIf
endClass

class BossError : Error;

class BossType
  PROPERTIES
    vm                 : BossVM
    slot_count         : Int32
    type_index         : Int32
    name_index         : Int32
    is_numberlike      : Logical
    method_indices     = Int32[](5)
    method_slot_lookup = Table<<Int32,Int32>>()
    base_types         = BossType[](2)
    is_visited         : Logical  # helper flag for recursive searches

  METHODS
    method init( vm, name:String, slot_count=2, is_numberlike=false )
      name_index = vm.identifiers.index( name )

      local entry = vm.type_lookup.find( name )
      if (entry)
        # Replace existing type definition
        type_index = entry.value.type_index
        vm.types[ type_index ] = this
      else
        type_index = vm.types.count
        vm.types.add( this )
      endIf
      vm.type_lookup[ name ] = this

    method extends( type_name:String )->this
      if (not this.is_object) throw BossError( "Non-object type $ cannot have a base type." (this) )

      local base_type = vm.find_type( type_name )
      if (not base_type) base_type = vm.define_type( base_type )

      if (not base_type.is_object) throw BossError( "Type $ cannot extend non-object type $." (this,base_type) )

      if (base_type.instance_of(this))
        throw BossError( "Attempted circular inheritance - $ cannot extend $ because $ extends $." (this,base_type,base_type,this) )
      endIf

      if ((forEach in base_types) is base_type) return this   # already in list

      base_types.add( base_type )
      return this

    method add_method( m:BossMethod )->BossMethod
      local entry = method_slot_lookup.find( m.name_index )
      if (entry)
        m.method_index = vm.methods[ entry.value ].method_index
        vm.methods[ m.method_index ] = m
      else
        m.method_index = vm.methods.count
        vm.methods.add( m )
        local slot = method_indices.count
        method_indices.add( m.method_index )
        method_slot_lookup[ m.name_index ] = slot
      endIf
      return m

    method create_method( m_name:String, native_handler=null:Function(BossTask) )->BossMethod
      return add_method( BossMethod(m_name,native_handler) )

    method instance_of( base_type:BossType )->Logical
      if (this is base_type) return true
      if ((forEach in base_types).instance_of(base_type)) return true
      if (not this.is_object) return false
      if (base_type is vm.type_Object) return true
      return false

    method is_int32->Logical
      return false

    method is_logical->Logical
      return false

    method is_null->Logical
      return false

    method is_number->Logical
      return false

    method is_object->Logical
      return false

    method is_real64->Logical
      return false

    method is_string->Logical
      return false

    method is_undefined->Logical
      return false

    method locate_method( m_name:String )->Int32?
      return locate_method( vm.identifiers.index(m_name) )

    method locate_method( m_name_index:Int32 )->Int32?
      local entry = method_slot_lookup.find( m_name_index )
      if (entry)
        return entry.value
      endIf

      local result : BossMethod
      forEach (base_type in base_types step -1)
        result = base_type._find_method_recursively( m_name_index )
        if (result) escapeForEach
      endForEach

      (forEach in vm.visited_types).is_visited = false
      vm.visited_types.clear

      if (result)
        add_method( result )
        return locate_method( m_name_index )  # will work for sure
      endIf

      return null

    method _find_method_recursively( m_name_index:Int32 )->BossMethod
      if (is_visited) return null

      local entry = method_slot_lookup.find( m_name_index )
      if (entry) return vm.methods[ method_indices[ entry.value ] ]

      is_visited = true
      vm.visited_types.add( this )

      # Search base types in reverse order
      forEach (base_type in base_types step -1)
        local result = base_type._find_method_recursively( m_name_index )
        if (result) return result
      endForEach

      return null

    method name->String
      return vm.identifiers[ name_index ]

    method op_add( stack:Real64[], lhs_sp:Int32, rhs_sp:Int32, rhs_type:BossType )
      stack.add( vm.type_undefined.type_index )

    method to->Int32( stack:Real64[], sp:Int32 )
      return 0

    method to->Logical( stack:Real64[], sp:Int32 )
      return false

    method to->Real64( stack:Real64[], sp:Int32 )
      return 0.0

    method to->String
      return name

    method to->String( stack:Real64[], sp:Int32 )
      return name + "@" + sp
endClass


class BossTypeInt32 : BossType
  METHODS
    method init( vm:BossVM )
      prior.init( vm, "Int32", &is_numberlike )

    method is_int32->Logical
      return true

    method is_number->Logical
      return true

    method to->Int32( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]->Int32

    method to->Logical( stack:Real64[], sp:Int32 )
      return (stack[sp+1] != 0)

    method to->Real64( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]

    method to->String( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]->Int32->String
endClass


class BossTypeLogical : BossType
  METHODS
    method init( vm:BossVM )
      prior.init( vm, "Logical", &is_numberlike )

    method is_logical->Logical
      return true

    method to->Int32( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]->Int32

    method to->Logical( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ] != 0

    method to->Real64( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]

    method to->String( stack:Real64[], sp:Int32 )
      return ?:{ stack[sp+1]:"true" || "false" }

endClass


class BossTypeNull : BossType
  METHODS
    method init( vm:BossVM )
      prior.init( vm, "null", &slot_count=1, &is_numberlike )

    method is_null->Logical
      return true

    method to->String( stack:Real64[], sp:Int32 )
      return "null"
endClass


class BossTypeObject : BossType
  METHODS
    method init( vm:BossVM, type_name="Object":String )
      prior.init( vm, type_name )

    method is_object->Logical
      return true

    method to->Logical( stack:Real64[], sp:Int32 )
      return true

    method to->String( stack:Real64[], sp:Int32 )
      return BossVM.objects[ stack[ sp+1 ] ]->String
endClass


class BossTypeReal64 : BossType
  METHODS
    method init( vm:BossVM )
      prior.init( vm, "Real64", &is_numberlike )

    method is_number->Logical
      return true

    method is_real64->Logical
      return true

    method to->Int32( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]->Int32

    method to->Logical( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ] != 0

    method to->Real64( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]

    method to->String( stack:Real64[], sp:Int32 )
      return stack[ sp+1 ]->String
endClass


class BossTypeString : BossType
  METHODS
    method init( vm:BossVM )
      prior.init( vm, "String" )

    method is_string->Logical
      return true

    method to->Int32( stack:Real64[], sp:Int32 )
      return BossVM.strings[ stack[ sp+1 ] ]->Int32

    method to->Logical( stack:Real64[], sp:Int32 )
      return true

    method to->Real64( stack:Real64[], sp:Int32 )
      return BossVM.strings[ stack[ sp+1 ] ]->Real64

    method to->String( stack:Real64[], sp:Int32 )
      return BossVM.strings[ stack[ sp+1 ] ]
endClass


class BossTypeUndefined : BossType
  METHODS
    method init( vm:BossVM )
      prior.init( vm, "undefined", &slot_count=1 )

    method is_undefined->Logical
      return true

    method to->String( stack:Real64[], sp:Int32 )
      return "undefined"
endClass


class BossObject
  PROPERTIES
    type         : BossType
    object_index : Int32

  METHODS
    method init( type_name:String )
      type = ?:{ BossVM.type_lookup[type_name] || BossVM.type_Object }
      object_index = BossVM.add_object( this )

    method call( method_name:String )->BossTask
      local slot = type.locate_method( method_name )
      if (slot.exists)
        local task = BossTask( type.vm.methods[ type.method_indices[slot.value] ] )
        task.push( this )
        task.execute
        return task
      else
        return BossVM.no_such_method
      endIf
endClass


enum BossOpcode
  NOP
  HALT
  RETURN
  CALL
  REPEAT
  LITERAL_INT32
  LITERAL_REAL64
  STRING
  READ_THIS
  READ_ARG_1
  READ_ARG_2
  READ_ARG_3
  READ_ARG_N
  ADD
  PRINT
  PRINTLN
endEnum


class BossMethod
  PROPERTIES
    name_index     : Int32
    method_index   : Int32
    code           : Int32[]
    native_handler : Function(BossTask)

  METHODS
    method init( name:String, native_handler=null )
      name_index = BossVM.identifiers.index( name )
      ensure code

    method ip->Int32
      return code.count

    method name->String
      return BossVM.identifiers[ name_index ]

    method to->String
      return name + "()"

    method write( opcode:BossOpcode, value:Int32 )
      write( opcode->Int32 )
      write( value )

    method write( opcode:BossOpcode, value:Real64 )
      write( opcode->Int32 )
      write( BossVM.real64s.count )
      BossVM.real64s.add( value )

    method write( opcode:BossOpcode, value:String )
      write( opcode->Int32 )
      write( value )

    method write( opcode:BossOpcode )
      code.add( opcode->Int32 )

    method write( value:Int32 )
      code.add( value )

    method write( value:String )
      write( BossVM.strings.index(value) )

    method write_call( method_name:String, arg_count=0:Int32 )
      write( BossOpcode.CALL )
      write( BossVM.identifiers.index(method_name) )
      write( 0 )
      write( 0 )
      write( arg_count )

endClass


class BossCallFrame( m:BossMethod, fp=0:Int32, arg_count=0:Int32, ip=0:Int32 ) [compound]
  METHODS
    method to->String
      return "$ @$" (m,ip)
endClass


class BossTask
  PROPERTIES
    vm          : BossVM
    stack       : Real64[]
    stack_index : Int32[]
    frame       : BossCallFrame
    call_stack  : BossCallFrame[]

    exists      = true
      # false if this task was created to handle a call to a method that did not exist
    is_finished : Logical

    repeat_call : Logical

  METHODS
    method init
      exists = false
      is_finished = true
      vm = BossVM
      (ensure stack_index(1)).add( 0 )
      (ensure stack(1)).add( vm.type_undefined.type_index )

    method init( m:BossMethod )
      ensure stack
      ensure stack_index
      ensure call_stack

      vm = BossVM
      frame = BossCallFrame( m )

    method arg_count->Int32
      return frame.arg_count

    method arg_int32( index:Int32 )->Int32
      local type = arg_type( index )
      if (type.is_undefined) return 0
      return type->Int32( stack, stack_index[frame.fp+index] )

    method arg_logical( index:Int32 )->Logical
      local type = arg_type( index )
      if (type.is_undefined) return 0
      return type->Logical( stack, stack_index[frame.fp+index] )

    method arg_real64( index:Int32 )->Real64
      local type = arg_type( index )
      if (type.is_undefined) return 0.0
      return type->Int32( stack, stack_index[frame.fp+index] )

    method arg_string( index:Int32 )->String
      local type = arg_type( index )
      if (type.is_undefined) return 0
      return type->String( stack, stack_index[frame.fp+index] )

    method arg_type( index:Int32 )->BossType
      if (index < 0 or index > frame.arg_count) return vm.type_undefined
      return vm.types[ stack[stack_index[frame.fp + index]] ]

    method execute->Logical
      if (is_finished) return false

      local vm          = this.vm
      local stack       = this.stack
      local stack_index = this.stack_index
      local frame       = this.frame
      local code        = frame.m.code
      local types       = vm.types
      loop
        local opcode = BossOpcode( code[ frame.ip ] )
        ++frame.ip
        which (opcode)
          case BossOpcode.NOP
            noAction

          case BossOpcode.HALT
            this.frame = frame
            is_finished = true
            return false

          case BossOpcode.RETURN
            local result_sp = stack_index.last
            local is_return_value_specified = stack_index.count > (frame.fp+frame.arg_count+1)

            # Unwind stack
            local should_halt = false
            if (call_stack.count)
              local old_fp = frame.fp
              frame = call_stack.remove_last
              stack.count = stack_index[ old_fp ]
              stack_index.count = old_fp + 1    # stack_index.last has correct value
              code = frame.m.code
            else
              # set count instead of clear() to avoid zeroing data; stack_index.last has correct value
              stack_index.count = 1
              stack.count = 0
              should_halt = true
            endIf

            if (is_return_value_specified)
              # The stack has at least one extra value on it; copy it over as the result
              loop types[ stack[result_sp] ].slot_count
                stack.add( stack[result_sp] )
                ++result_sp
              endLoop
            else
              # No return value pushed on stack; add an 'undefined'.
              stack.add( vm.type_undefined.type_index )
            endIf

            if (should_halt)
              this.frame = frame
              is_finished = true
              return false
            endIf

          case BossOpcode.CALL
            # code[ip-5] : CALL
            # code[ip-4] : method name_index
            # code[ip-3] : cached type index
            # code[ip-2] : cached method slot
            # code[ip-1] : N (arg count)
            block
              frame.ip += 4
              local arg_count     = code[ frame.ip - 1 ]
              local context_index = stack_index.count - (arg_count+1)
              local context_sp    = stack_index[ context_index ]
              local context_type  = types[ stack[context_sp] ]
              local m : BossMethod
              if (context_type.type_index == code[frame.ip-3])
                m = vm.methods[ context_type.method_indices[ code[frame.ip-2] ] ]
              else
                local slot = context_type.locate_method( code[frame.ip-4] )
                if (slot.exists)
                  # Cache type index and slot index
                  code[ frame.ip-3 ] = context_type.type_index
                  code[ frame.ip-2 ] = slot.value
                  m = vm.methods[ context_type.method_indices[ slot.value ] ]
                else
                  # Method not found; pop context + args and replace with "undefined"
                  stack_index.count = context_index + 1
                  stack.count = context_sp + 1
                  stack[ context_sp ] = vm.type_undefined.type_index
                  escapeBlock
                endIf
              endIf
              call_stack.add( frame )
              frame = BossCallFrame( m, context_index, arg_count )
              if (m.native_handler)
                this.frame = frame
                m.native_handler( this )   # may set 'repeat_call'
                if (repeat_call)
                  repeat_call = false
                  frame = call_stack.remove_last
                  frame.ip -= 5
                  return true  # pause for now but keep running task
                else
                  # perform RETURN
                  local result_sp = stack_index.last
                  local is_return_value_specified = stack_index.count > (frame.fp+frame.arg_count+1)

                  # Unwind stack
                  local old_fp = frame.fp
                  frame = call_stack.remove_last
                  stack.count = stack_index[ old_fp ]
                  stack_index.count = old_fp + 1    # stack_index.last has correct value
                  code = frame.m.code

                  if (is_return_value_specified)
                    # The stack has at least one extra value on it; copy it over as the result
                    loop types[ stack[result_sp] ].slot_count
                      stack.add( stack[result_sp] )
                      ++result_sp
                    endLoop
                  else
                    # No return value pushed on stack; add an 'undefined'.
                    stack.add( vm.type_undefined.type_index )
                  endIf
                endIf
              else
                code = m.code
              endIf
            endBlock

          case BossOpcode.REPEAT
            if (code[frame.ip])
              --code[ frame.ip ]
              frame.ip = code[ frame.ip + 1 ]
            else
              frame.ip += 2
            endIf

          case BossOpcode.LITERAL_INT32
            stack_index.add( stack.count )
            stack.add( vm.type_Int32.type_index )
            stack.add( code[frame.ip] )
            ++frame.ip

          case BossOpcode.LITERAL_REAL64
            stack_index.add( stack.count )
            stack.add( vm.type_Real64.type_index )
            stack.add( vm.real64s[code[frame.ip]] )
            ++frame.ip

          case BossOpcode.STRING
            stack_index.add( stack.count )
            stack.add( vm.type_String.type_index )
            stack.add( code[frame.ip] )
            ++frame.ip

          case BossOpcode.READ_THIS
            stack_index.add( stack.count )
            local src = stack_index[ frame.fp ]
            local type_index = stack[ src ]
            loop types[ type_index ].slot_count
              stack.add( stack[src] )
              ++src
            endLoop

          case BossOpcode.READ_ARG_1
            stack_index.add( stack.count )
            local src = stack_index[ frame.fp + 1 ]
            local type_index = stack[ src ]
            loop types[ type_index ].slot_count
              stack.add( stack[src] )
              ++src
            endLoop

          case BossOpcode.READ_ARG_2
            stack_index.add( stack.count )
            local src = stack_index[ frame.fp + 2 ]
            local type_index = stack[ src ]
            loop types[ type_index ].slot_count
              stack.add( stack[src] )
              ++src
            endLoop

          case BossOpcode.READ_ARG_3
            stack_index.add( stack.count )
            local src = stack_index[ frame.fp + 3 ]
            local type_index = stack[ src ]
            loop types[ type_index ].slot_count
              stack.add( stack[src] )
              ++src
            endLoop

          case BossOpcode.READ_ARG_N
            stack_index.add( stack.count )
            local src = stack_index[ frame.fp + code[frame.ip] ]
            ++frame.ip
            local type_index = stack[ src ]
            loop types[ type_index ].slot_count
              stack.add( stack[src] )
              ++src
            endLoop

          case BossOpcode.ADD
            local rhs_sp = stack_index.remove_last
            local lhs_sp = stack_index.last
            stack.count = lhs_sp
            vm.op_add( stack, lhs_sp, types[stack[lhs_sp]->Int32], rhs_sp, types[stack[rhs_sp]->Int32] )

          case BossOpcode.PRINT
            local sp = stack_index.remove_last
            print vm.types[ stack[sp]->Int32 ]->String( stack, sp )
            stack.count = sp

          case BossOpcode.PRINTLN
            println

          others
            throw Error( "Unhandled opcode in BossVM: " + opcode )
        endWhich
      endLoop

    method peek_type->BossType
      if (stack_index.count == 0) return vm.type_undefined
      return vm.types[ stack[ stack_index.last ] ]

    method push( value:Int32 )->this
      stack_index.add( stack.count )
      stack.add( vm.type_Int32.type_index )
      stack.add( value )
      return this

    method push( value:Logical )->this
      stack_index.add( stack.count )
      stack.add( vm.type_Logical.type_index )
      stack.add( ?:{value:1||0} )
      return this

    method push( value:BossObject )->this
      if (value is null) return push_null
      stack_index.add( stack.count )
      stack.add( value.type.type_index  )
      stack.add( value.object_index  )
      return this

    method push( value:Real64 )->this
      stack_index.add( stack.count )
      stack.add( vm.type_Real64.type_index )
      stack.add( value )
      return this

    method push( value:String )->this
      if (value is null) return push_null
      stack_index.add( stack.count )
      stack.add( vm.type_String.type_index )
      stack.add( vm.strings.add(value) )
      return this

    method push_null->this
      stack_index.add( stack.count )
      stack.add( vm.type_null.type_index )
      return this

    method push_undefined->this
      stack_index.add( stack.count )
      stack.add( vm.type_undefined.type_index )
      return this

    method result_type->BossType

endClass


class BossStringIndexTable
  PROPERTIES
    list  : String[]
    table = StringTable<<Int32>>()

  METHODS
    method init
      init( 10 )

    method init( initial_capacity:Int32 )
      ensure list( initial_capacity )

    method add( value:String )->Int32
      # Adds a string without comparing it to existing strings
      list.add( value )
      return list.count - 1

    method count->Int32 [macro]
      this.list.count

    method get( index:Int32 )->String
      return list[ index ]

    method index( value:String )->Int32
      local entry = table.find( value )
      if (entry) return entry.value

      local index = list.count
      list.add( value )
      table[ value ] = index
      return index

endClass

